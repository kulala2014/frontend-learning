<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="./demo.js"></script>
    <link rel="stylesheet" href="./demo.css">
</head>

<body>
    <a href="#" id="size-12">12</a>
    <a href="#" id="size-14">14</a>
    <a href="#" id="size-16">16</a>
    <h1>闭包</h1>
    <pre>
        <p>闭包：一个函数和其周围状态得引用捆绑在一起，这样得组合叫闭包。</p>
        <p>在一个内层函数中访问到其外层函数的作用域。</p>
        <p>在JavaScript中，每当创建一个函数，闭包就会在函数创建的同事被创建出来。</p>
    <code>
        function init() {
            var name = "Mozilla"; // name 是一个被 init 创建的局部变量
            function displayName() { // displayName() 是内部函数，一个闭包
                alert(name); // 使用了父函数中声明的变量
            }
            displayName();
        }
        init();
    </code>
    <p>init()创建了一个局部变量name和一个名为displayName的函数。displayName 是定义在init里的内部函数，病情尽在init函数体内可用。</p>
    <p>displayName没有自己的局本变量。然而它可以访问外部函数的变量，所以displayName可以使用父函数init中声明的变量name。</p>

    <code>
        function makeFunc() {
            var name = "Mozilla";
            function displayName() {
                alert(name);
            }
            return displayName;
        }
        
        var myFunc = makeFunc();
        myFunc();
    </code>
    <p>闭包是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量</p>
    <code>
        function makeAdder(x) {
            return function(y) {
              return x + y;
            };
          }
          
          var add5 = makeAdder(5);
          var add10 = makeAdder(10);
          
          console.log(add5(2));  // 7
          console.log(add10(2)); // 12
    </code>
    <p>在这个示例中，我们定义了 makeAdder(x) 函数，它接受一个参数 x ，并返回一个新的函数。返回的函数接受一个参数 y，并返回x+y的值。</p>
    <p>从本质上讲，makeAdder 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。</p>
    <p>add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。</p>
    </pre>
</body>

</html>